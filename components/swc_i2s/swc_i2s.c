#include <stdio.h>
#include <sys/param.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2s.h"
#include "soc/i2s_reg.h"
#include "swc_i2s.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_err.h"

int32_t*  i2s_read_buff; //Comented out in order to declare it as extern
int8_t* i2s_write_buff;
//Driver struct


void i2s_rx_init(){

    static const i2s_config_t i2s_configuration_rx = {
    // The ESP32 is the MASTER. The BCLOCK and WS are generated by the ESP32
    .mode = I2S_MODE_MASTER | I2S_MODE_RX, 
    .sample_rate = I2S_SAMPLE_RATE, // 16Khz
    .bits_per_sample = I2S_BITS_SAMPLE, // 32 bits
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT, // L/R is grounded, only left. MONO
    .communication_format = I2S_COMM_FORMAT_STAND_I2S,
    //  The default data format is I²S (two’s complement), MSB-first. 
    // In this format, the MSB of each word is delayed by one SCK cycle from the start of each half-frame.
    //The SPH MIC does not use this format. The MSB is delayed half SCK cycle
    .tx_desc_auto_clear = false,
    .dma_buf_count = 4, //buffers not free until DMA has written and also cpu has read them once dma wrote 
    .dma_buf_len = 1024, // Max length available so if server takes a lot to answer we accomulate data.
    .use_apll = false,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1  // Interrupt level 1, default 0
    };

    static const i2s_pin_config_t pin_configuration_rx = {
            .mck_io_num = I2S_PIN_NO_CHANGE,
            .bck_io_num = I2S_BCLK_RX,
            .ws_io_num = I2S_WS_RX,
            .data_out_num = I2S_PIN_NO_CHANGE,
            .data_in_num = I2S_DATA_IN
    };

    if (ESP_OK != i2s_driver_install(I2S_RX_PORT, &i2s_configuration_rx, 0, NULL)) {
    printf("ERROR : i2s_driver_install");
    }
    
	//FIX for MIC. MSB bit comes after one bclock after WS not one bit afert WS.
	REG_SET_BIT(I2S_TIMING_REG(I2S_RX_PORT),BIT(9));
	REG_SET_BIT(I2S_CONF_REG(I2S_RX_PORT),I2S_RX_MSB_SHIFT);

    if (ESP_OK != i2s_set_pin(I2S_RX_PORT, &pin_configuration_rx)) {
    printf("ERROR : i2s_set_pin");}

    i2s_zero_dma_buffer(I2S_RX_PORT);
}

void i2s_tx_init(){

        static const i2s_config_t i2s_configuration_tx = {

        .mode = I2S_MODE_MASTER | I2S_MODE_TX,
        .sample_rate = I2S_SAMPLE_RATE_TX, // 16Khz
        .bits_per_sample = I2S_BITS_SAMPLE_TX, // 16 bits 
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT, // L/R is grounded, only left
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        // The information received is in this format
        .dma_buf_count = 4, //buffers not free until DMA has written 
                            //and also cpu has read them once dma wrote 
        .dma_buf_len = 256, // Max length available so if server 
                            //takes a lot to answer we accomulate data.
        .use_apll = false,
        .tx_desc_auto_clear = true, // See if tx descriptor needs to be auto cleared:
                                    // This will avoid any kind of noise that may 
                                    //get introduced due to transmission
                                    // of previous data from tx descriptor on I2S line.
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,// Interrupt level 1, default 0
        .fixed_mclk= 0
    };

    static const i2s_pin_config_t pin_configuration_tx = {
            .mck_io_num = I2S_PIN_NO_CHANGE,
            .bck_io_num = I2S_BCLK_TX,
            .ws_io_num = I2S_WS_TX,
            .data_out_num = I2S_DATA_OUT,
            .data_in_num = I2S_PIN_NO_CHANGE
    };

    if (ESP_OK != i2s_driver_install(I2S_TX_PORT, &i2s_configuration_tx, 0, NULL)) {
    printf("ERROR : i2s_driver_install");
    }
    if (ESP_OK != i2s_set_pin(I2S_TX_PORT, &pin_configuration_tx)) {
    printf("ERROR : i2s_set_pin");}

    i2s_zero_dma_buffer(I2S_TX_PORT);
}

void i2s_buff_init()
{

    i2s_read_buff = (int32_t*) calloc(512,sizeof(int32_t));  

}

wav_header_t wav_head_init(){  

    wav_header_t wav_header = {

        .descriptor_chunk = {
            .chunk_id[0] = 'R', //Initializes chunk ID as big endian
            .chunk_id[1] = 'I',
            .chunk_id[2] = 'F',
            .chunk_id[3] = 'F',
            .chunk_size = 0,
            .chunk_format[0] = 'W', //Initializes format as big endian
            .chunk_format[1] = 'A',
            .chunk_format[2] = 'V',
            .chunk_format[3] = 'E',
        },
        .fmt_subchunk = {
            .subchunk_id[0] = 'f', //Initializes subchunk1 ID as big endian
            .subchunk_id[1] = 'm',
            .subchunk_id[2] = 't',
            .subchunk_id[3] = ' ',
            .subchunk_size = 16,
            .audio_format = 1,
            .num_channels = 1,
            .sample_rate = I2S_SAMPLE_RATE,
            .byte_rate = I2S_SAMPLE_RATE * 16 * 1 / 8,
            .block_align = 2,
            .bits_per_sample = 16,
        },
        .data_subchunk = {
            .subchunk2_id[0] = 'd', //Initializes subchunk2 ID as big endian
            .subchunk2_id[1] = 'a',
            .subchunk2_id[2] = 't',
            .subchunk2_id[3] = 'a',
            .subchunk2_size = 0,
        },
    };

    return wav_header;

}

void i2s_read_data()
{
    size_t bytes_read;
    
    if(ESP_OK == i2s_read(I2S_RX_PORT,(void *)i2s_read_buff,50*sizeof(uint32_t), &bytes_read,50)){
    printf("Number of bytes read %d",bytes_read);
    for(int i=0;i<bytes_read;i++)
    {
    	i2s_read_buff[i] = (int16_t) (i2s_read_buff[i]>>16);
        //printf("%0x /n", i2s_read_buff[i]);
    }
    }
    else{
        printf("ERROR : i2s read error");
    }
    
}


size_t  sample_32bit_to_16bit(int32_t* i2s_read_buff,
                             size_t bytes_read, 
                            char * buffer ,size_t max_size,
                            uint8_t type)
{
    uint16_t sample_size = bytes_read/4;
    uint16_t aux_i = 0;
    if(sample_size > 1024) 
    {
        sample_size = 1024;
    }

    bytes_read = bytes_read/2 + 2;
    if( type == 0){
        buffer[0] = 0x01;
        buffer[1] = 0x03;
        aux_i = 2;
    }
    else if (type == 1){

        buffer[21] = 0x01;
        buffer[22] = 0x03;
        aux_i = 23;
    }
    else 
    {

    }
    for(int i = 0;i<sample_size;i++)
    {
       
        i2s_read_buff[i] = (i2s_read_buff[i] & 0xFFFFFFFF)>>16;
        
        buffer[i*2 + aux_i] = (i2s_read_buff[i] & 0xFF);
        buffer[i*2 + 1 + aux_i] =  (i2s_read_buff[i] & 0xFFFF)>>8;



    }
    return bytes_read;
}

void i2s_init()
{
    i2s_rx_init();
    i2s_tx_init();
    i2s_buff_init();
}
